# -*- coding: utf-8 -*-
"""Lab2_Bài_tập 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XeH1xd2DYc_W12TuC8pYPGA3_KWq_pQ1
"""

from PIL import Image
import math
import scipy
import cv2
import numpy as np
import imageio.v2 as iio
import matplotlib.pylab as plt
from google.colab.patches import cv2_imshow

def fast_fourier(img):
  img_arr = np.asarray(img)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  d = d.astype(np.uint8)
  ff_im = Image.fromarray(d)
  return ff_im

def butterworth_lowpass_fillter(img):
  img_arr = np.asarray(img)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  #initializing variables for convolution function
  M = d.shape[0]
  N = d.shape[1]
  #H is defined and values in H are initialized to 1
  H = np.ones((M,N))

  center1 = M/2
  center2 = N/2
  d_0 = 30.0
  t1 = 1
  t2 = 2 * t1

  #defining the convolution function for BLPF
  for i in range(1,M):
    for j in range(1,N):
      r1 = (i - center1) **2 + (j - center2) **2
      #euclidean distance from origin is computed
      r = math.sqrt(r1)
      #using cut-off radius to eliminate high frequency
      if r > d_0:
        H[i,j] = 1/(1 + (r/d_0)**t1)
  #H is converted from ndarray to image
  H = H.astype(float)
  H = Image.fromarray(H)
  # performing the convolution
  con = d * H
  # computing the magnitude of the inverse FFT
  e = abs(scipy.fftpack.ifft2(con))
  #e is converted from ndarray to image
  e  = e.astype(np.uint8)
  blf_im  = Image.fromarray(e)
  return blf_im

def butterworth_highpass_filter(img):
  img_arr = np.asarray(img)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  M = d.shape[0]
  N = d.shape[1]
  #H is defined and values in H are initialized to 1
  H = np.ones((M,N))
  center1 = M/2
  center2 = N/2
  d_0 = 30.0
  t1 = 1
  t2 = 2 * t1

  #defining the convolution function for BLPF
  for i in range(1,M):
    for j in range(1,N):
      r1 = (i - center1)**2 + (j - center2)**2
      # euclidean distance from origin is computed
      r = math.sqrt(r1)
      # using cut-off radius to eliminate high freqency
      if r > d_0:
        H[i,j] = 1/(1 + (r/d_0) **t2)
  #H is converted from ndarray to image
  H = H.astype(float)
  H = Image.fromarray(H)
  #performing the convolution
  con = d *  H
  # computing the magnitude of the inverse FFT
  e = abs(scipy.fftpack.ifft2(con))
  #e is converted from ndarray to image
  e = e.astype(np.uint8)
  bhf_im  = Image.fromarray(e)
  return bhf_im

def display_img(img):
  img.show()
  plt.imshow(img)
  plt.show()

def main():
  origin_im = Image.open('pagoda.jpg').convert('L')
  transformed_image = origin_im.copy()


  while True:
    print("Chọn phương pháp biến đổi ảnh:")
    print("F -  Fast Fourier")
    print("L - Butterworth Lowpass Filter")
    print("H - Butterworth Highpass Filter")

    choice = input("Lựa chọn của bạn: ").upper()
    if choice == "Q":
        break

    elif choice == "F":
        transformed_image = fast_fourier(transformed_image)

    elif choice == "L":
        transformed_image = butterworth_lowpass_fillter(transformed_image)

    elif choice == "H":
        transformed_image = butterworth_highpass_filter(transformed_image)

    display_img(transformed_image)
    iio.imsave("transformed_image.jpg",transformed_image)
    # Lưu ảnh đã biến đổi thành file

if __name__ == "__main__":
  main()