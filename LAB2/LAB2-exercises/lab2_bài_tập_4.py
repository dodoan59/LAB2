# -*- coding: utf-8 -*-
"""LAB2_BÀI_TẬP_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qbk-683YTQxSPmMy6KhsCyO9367wp8Wa
"""

from PIL import Image
import math
import scipy
import cv2
import numpy as np
import imageio.v2 as iio
import matplotlib.pylab as plt
import random
import scipy.ndimage as sn

image = cv2.imread('pagoda.jpg')
b, g, r = cv2.split(image)
image_rgb = cv2.merge([g , r, b])
index = random.randint(0,2)
#fast_fourier
if index == 0:
  print("Biến đổi ảnh Fast_Fourier")
  img_arr = np.asarray(image_rgb)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  d = d.astype(np.uint8)
  result_img = Image.fromarray(d)

#Butterworth_Lowpass_Fillter
elif index == 1:
  print("Biến đổi ảnh Butterworth_Lowpass_Fillter")
  #Lọc ảnh với Min fillter
  a = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
  a = a.astype(np.uint8)
  b = sn.minimum_filter(a, size = 5, footprint = None, output = None,
                      mode = 'reflect', cval = 0.0, origin = 0)
  img_arr = np.asarray(b)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  #initializing variables for convolution function
  M = d.shape[0]
  N = d.shape[1]
  #H is defined and values in H are initialized to 1
  H = np.ones((M,N))

  center1 = M/2
  center2 = N/2
  d_0 = 30.0
  t1 = 1
  t2 = 2 * t1

  #defining the convolution function for BLPF
  for i in range(1,M):
    for j in range(1,N):
      r1 = (i - center1) **2 + (j - center2) **2
      #euclidean distance from origin is computed
      r = math.sqrt(r1)
      #using cut-off radius to eliminate high frequency
      if r > d_0:
        H[i,j] = 1/(1 + (r/d_0)**t1)
  #H is converted from ndarray to image
  H = H.astype(float)
  H = Image.fromarray(H)
  # performing the convolution
  con = d * H
  # computing the magnitude of the inverse FFT
  e = abs(scipy.fftpack.ifft2(con))
  #e is converted from ndarray to image
  e  = e.astype(np.uint8)
  result_img  = Image.fromarray(e)
elif index == 2:
  print("Biến đổi ảnh Butterworth_Highpass _Fillter")
  #Lọc ảnh với Max filter
  a = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2GRAY)
  a = a.astype(np.uint8)
  b = sn.maximum_filter(a, size = 5, footprint = None, output = None,
                      mode = 'reflect', cval = 0.0, origin = 0)
  img_arr = np.asarray(b)
  c = abs(scipy.fftpack.fft2(img_arr))
  d = scipy.fftpack.fftshift(c)
  M = d.shape[0]
  N = d.shape[1]
  #H is defined and values in H are initialized to 1
  H = np.ones((M,N))
  center1 = M/2
  center2 = N/2
  d_0 = 30.0
  t1 = 1
  t2 = 2 * t1

  #defining the convolution function for BLPF
  for i in range(1,M):
    for j in range(1,N):
      r1 = (i - center1)**2 + (j - center2)**2
      # euclidean distance from origin is computed
      r = math.sqrt(r1)
      # using cut-off radius to eliminate high freqency
      if r > d_0:
        H[i,j] = 1/(1 + (r/d_0) **t2)
  #H is converted from ndarray to image
  H = H.astype(float)
  H = Image.fromarray(H)
  #performing the convolution
  con = d *  H
  # computing the magnitude of the inverse FFT
  e = abs(scipy.fftpack.ifft2(con))
  e = e.astype(np.uint8)
  #e is converted from ndarray to image
  result_img  = Image.fromarray(e)

# Hiển thị ảnh đã biến đổi
result_img.show()
plt.imshow(result_img)
plt.show()
# Lưu ảnh đã biến đổi
iio.imsave('result_image.jpg',result_img)