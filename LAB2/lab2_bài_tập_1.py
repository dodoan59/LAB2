# -*- coding: utf-8 -*-
"""LAB2_BÀI_TẬP_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14baRkwwp_hLNSzX_VAR-eWYwPwUg7H3e
"""

from PIL import Image
import math
import scipy
import cv2
import numpy as np
import imageio.v2 as iio
import matplotlib.pylab as plt
from google.colab.patches import cv2_imshow

import cv2
def inverse(img):
  img_arr = np.asarray(img)
  inverse = 255 - img_arr
  inverse_img = Image.fromarray(inverse)
  return inverse_img

def gamma_correction(img, gamma):
  #convert ndarray from int to float
  img_arr = np.asarray(img)
  b1 = img_arr.astype(float)
  b2 = np.max(b1)
  b3 = b1/b2
  b2 = np.log(b3) * gamma

#gamma correction is computed
  c = np.exp(b2) * 255.0
#c1 is converted to type int
  c1 = c.astype(np.uint8)

  corrected_img = Image.fromarray(c1)
  return corrected_img

def log_transformation(img):
  #convert ndarray from int to float
  img_arr = np.asarray(img)
  b1 = img_arr.astype(float)

  #find maximum value in b1
  b2 = np.max(b1)

  #performing the log transformation
  c = (128.0 * np.log(1 + b1))/np.log(1 + b2)

  #c1 is converted type int
  c1 = c.astype(np.uint8)

  d = c1
  log_img = Image.fromarray(c1)
  return log_img

def histogram_equalization(img):
  img_arr = np.asarray(img)

  #convert 2D ndarray from 1D array
  b1 = img_arr.flatten()

  #histogram and bin are computed
  hist, bins = np.histogram(img_arr, 256, [0,255])

  #cumulative distribution function is computed
  cdf = hist.cumsum()

  #places where cdf = 0 is marked or ignored and
  #rest is stored in cdf_m
  cdf_m = np.ma.masked_equal(cdf,0)
  #histogram equalization is performed
  num_cdf_m = (cdf_m - cdf_m.min()) *255
  den_cdf_m = (cdf.max() - cdf_m.min())
  cdf_m = num_cdf_m/den_cdf_m

  #the masked places in cdf_m are now 0
  cdf = np.ma.filled(cdf_m,0).astype('uint8')

  #cdf values are assigned in the flattened array
  im2 = cdf[b1]

  #im2 is 1D so we use reshape command to
  #make it into 2D
  im3 = np.reshape(im2, img.shape)

  #converting im3 to an image
  equalized_img = Image.fromarray(im3)
  return equalized_img

def contrast_stretching(img):
  img_arr = np.asarray(img)
  #finding the maximun and minimum pixel values
  b = img.max()
  a = img.min()
  print(a,b)
  #converting img to float
  c = img_arr.astype(float)
  #contrast stretching transformation
  im2 = 255 * (c - a)/(b - a)
  #im2 is converted from ndarray to image
  im2 = img_arr.astype(np.uint8)
  stretched_img = Image.fromarray(im2)
  return stretched_img

def display_img(img):
  img.show()
  plt.imshow(img)
  plt.show()

def main():
  origin_im = Image.open('pagoda.jpg').convert('L')
  read_im = cv2.imread('pagoda.jpg',0)
  transformed_image = read_im.copy()


  while True:
    print("Chọn phương pháp biến đổi ảnh:")
    print("I - Image inverse transformation")
    print("G - Gamma-Correction")
    print("L - Log Transformation")
    print("H - Histogram equalization")
    print("C - Contrast Stretching")
    print("Q - Thoát chương trình")

    choice = input("Lựa chọn của bạn: ").upper()

    if choice == "Q":
        break

    elif choice == "I":
        transformed_image = inverse(transformed_image)

    elif choice == "G":
        gamma = float(input("Nhập giá trị gamma (vd: 1.5): "))
        transformed_image = gamma_correction(transformed_image, gamma)

    elif choice == "L":
        transformed_image = log_transformation(transformed_image)

    elif choice == "H":
        transformed_image = histogram_equalization(transformed_image)

    elif choice == "C":
        transformed_image = contrast_stretching(transformed_image)

    display_img(transformed_image)
    iio.imsave("transformed_image.jpg",transformed_image)
    # Lưu ảnh đã biến đổi thành file

if __name__ == "__main__":
  main()